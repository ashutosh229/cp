inbuilt functions:
swap(a,b);
max(a,b);
min(a,b);
__gcd(a,b);
pow(x,y);
minmax_element(arr, arr + n) {returns reference, so need to *}
numOfDigits(n) = log10(n) + 1
number of steps needed to reduce n to 0 via division by x = logx(n)
__builtin_popcount(j) counts the number of set bits in j if j is int type 
__builtin_popcountll(j) counts the number of set bits in j if j is long long int type 


begin();
end();

sort(initial_address, final_address, comparator_function); // nlogn //the comparator_function has some different working   
lower_bound(initial_address, final_address, element); // log(n) // returns pointer for array and iterator for vector
upper_bound(initial_address, final_address, element); //log(n) // returns pointer for array and iterator for vector
lower_bound/upper_bound(initial_address, final_address, element); //n //not used in sets and maps like this due to high time complexity
set.lower_bound(element); //logn //used in sets
map.lower_bound(key); //logn //gets applied on the key //used in maps 
lower_bound and upper_bound can be applied to pairs, strings also

min_element(initial_address, final_address) //returns address (pointer for array and iterator for vector) // n 
max_element(initial_address, final_address) //returns address (pointer for array and iterator for vector) // n
accumulate(initial_address, final_address, initial_sum) //returns the sum(container) + initial_sum // n
count(initial_address, final_address, element) //returns the count of the element // n
reverse(initial_address, final_address); //reverses the vector/array on point // n
find(initial_address, final_address, element) //returns the iterator/pointer of the element if found and v.end() if not found 
// n for others and logn for sets/maps and 1 for unordered 

lambda functions: 
[](int x){return x/2}(2); //calling a lambda function directly 
auto disum = [](int x,int y){return (x+y);}; //declaring a lambda function 
disum(2,3); //calling a declared lambda function  

all_of(initial_address, final_address, lambda_function) //returns true if lambda_function returns true for all 
any_of(initial_address, final_address, lambda_function) //returns true if lambda_function returns true for any 
none_of(initial_address, final_address, lambda_function) //returns true if lambda_function returns true for none 














tips:
we need to print the container in reverse due to order (insert the reverse order initially and print in forward)
when you need to check a lot of things against something, use maps for creating mapping for checking (check the paranthesis 
problem for reference)

cout << fixed << setprecision(3) << d << endl; // we can fix the number of digits after the decimal using this 







concepts:
breaking the string into space separated words (using cin)
converting the lowercase into uppercase(small - a = big - A)(distance between character)
binary strings
gcd with 0 is the number itself 
gcd of three numbers is the gcd of two and then the gcd of the answer with third 
gcd of array 
is palindrome(mirror image concept)
can palindrome pe possible by rearranging (use the concept of "(one odd and others even) or (none odd)")



comparison of composite datatypes:
     - pairs (first compare the first and if same, then the second)
     - sets/multisets (first compare the first and if same, then the second)
     - unordered_sets (cannot compare using < and >, must define some custom comparison logic)
     - maps/multimaps (first compare the first key and if same, then go the second key)
     - unordered_maps (cannot compare using < and >, must define some custom comparison logic)
     - vectors (first compare the first and if same, then do for the second)

iteration of containers:
- vector/set/map/multimap/multiset:
    - forward: 
        - size 
        - it (dont need to erase)
    - backward: 
        - size
        - it (need to erase, use --it)
        - it (dont need to erase, but use --it and not it-1)

- pair (dont need to)

- stacks:
    - forward:
        - size (or !is.empty())
        - it 
    - backward:
        - 

- queues:
    - forward:
        - size (or !is.empty()) 
        - it 
    - backward: 
        - 

- unordered_map/unordered_set:
    - forward 
        - it 
    - backward
        - copy to vector and reverse




    

