#include <vector>
#include <map>

using namespace std;

int solution(vector<vector<int>> lamps) {
    map<long long, int> delta;
    for (const auto& lamp : lamps) {
        long long center = lamp[0];
        long long radius = lamp[1];
        
        delta[center - radius]++;
        delta[center + radius + 1]--;
    }

    int max_lamps = -1;
    int current_lamps = 0;
    long long result_coordinate = 0;
    
    if (lamps.empty()) {
        return 0;
    }
    
    long long prev_coordinate = delta.begin()->first;

    for (const auto& pair : delta) {
        long long current_coordinate = pair.first;
        int change = pair.second;

        if (current_lamps > max_lamps) {
            max_lamps = current_lamps;
            result_coordinate = prev_coordinate;
        }

        current_lamps += change;
        prev_coordinate = current_coordinate;
    }
    
    return static_cast<int>(result_coordinate);
}







#include <vector>
#include <string>

using namespace std;

vector<string> solution(vector<vector<string>> paragraphs, vector<string> aligns, int width) {
    vector<string> result;
    string border(width + 2, '*');
    result.push_back(border);

    for (size_t i = 0; i < paragraphs.size(); ++i) {
        const auto& paragraph_words = paragraphs[i];
        const string& alignment = aligns[i];
        
        if (paragraph_words.empty()) {
            continue;
        }

        string current_line;

        for (const string& word : paragraph_words) {
            if (current_line.empty()) {
                current_line = word;
            } else {
                if (current_line.length() + 1 + word.length() <= width) {
                    current_line += " " + word;
                } else {
                    int padding_size = width - current_line.length();
                    string padding(padding_size, ' ');
                    string formatted_line;

                    if (alignment == "LEFT") {
                        formatted_line = current_line + padding;
                    } else {
                        formatted_line = padding + current_line;
                    }
                    
                    result.push_back("*" + formatted_line + "*");
                    current_line = word;
                }
            }
        }

        if (!current_line.empty()) {
            int padding_size = width - current_line.length();
            string padding(padding_size, ' ');
            string formatted_line;

            if (alignment == "LEFT") {
                formatted_line = current_line + padding;
            } else {
                formatted_line = padding + current_line;
            }
            
            result.push_back("*" + formatted_line + "*");
        }
    }

    result.push_back(border);
    return result;
}




int solution(vector<string> resources, int conversionRate) {
    int countA = 0;a
    for (const string& resource : resources) {
        if (resource == "A") {
            countA++;
        }
    }
    int countP = resources.size() - countA;

    int cycles = 0;
    while (true) {
        if (countP >= conversionRate) {
            countP -= conversionRate;
            countA++;
            cycles++;
        } else if (countA > 0) {
            countA--;
            countP++;
            cycles++;
        } else {
            break;
        }
    }
    return cycles;
}




int solution(vector<int> a) {
    int result = 0;
    for (int num : a) {
        string s = to_string(num);
        int zero_count = count(s.begin(), s.end(), '0');
        if (zero_count % 2 != 0) {
            result++;
        }
    }
    return result;
}



https://docs.google.com/forms/d/e/1FAIpQLSfXnObiA7Z7CQIHP3LG0-IFrDjQi1rEQjtHNe-oKdRXjC2bEQ/formResponse